include::header.adoc[]

:title: Assignment 02: C shell by the shore
:Author Initials: ASN
:Date:    2020-08-15
:Revision: 0.1
:ASST: shell-USERNAME

= {title}

**Due Tuesday, Feb 3, before midnight**

The goals for this assignment are:

* Working with stdout, stdin, and files
* Understanding redirection and pipes at the command line
* Working with system calls: read, write, open
* C practice

This is the first assignment of your shell project. To get started, 
click on this link:https://classroom.github.com/a/j-ws2ho7[Shell Project on Github]

:sectnums:

= Microcat

_By Dianna Xu_

In the file, `microcat.c`, implement a C program that concatenates and prints files 
to standard output. If no arguments are given, it takes input from stdin. 

[source, subs="quotes"]
----
$ **./microcat lyrics.txt**
What a beautiful face
I have found in this place
That is circling all round the sun
What a beautiful dream
That could flash on the screen
In a blink of an eye and be gone from me
Soft and sweet
Let me hold it close and keep it here with me
$ **cat lyrics.txt | ./microcat**
What a beautiful face
I have found in this place
That is circling all round the sun
What a beautiful dream
That could flash on the screen
In a blink of an eye and be gone from me
Soft and sweet
Let me hold it close and keep it here with me
$ **./microcat < lyrics.txt**
What a beautiful face
I have found in this place
That is circling all round the sun
What a beautiful dream
That could flash on the screen
In a blink of an eye and be gone from me
Soft and sweet
Let me hold it close and keep it here with me
$ **./microcat**
**hello**
hello
**nice hat**
nice hat
$ **./microcat B.txt A.txt C.txt D.txt**
World
Hello
!!!
All life is precious
----

Requirements/Hints:

* Use the low-level system calls for working with files: read, write, open

= Parser

NOTE: This question is from link:https://www.cs.swarthmore.edu/~kwebb/cs45/s24/labs/lab1.html[this lab].

In the file, `parser.c`, implement a function that parses command line input. 
This function should fill in a `struct Cmd` that holds the information needed to execute. Your struct should look as follows. 

[source]
----
struct Cmd {
  char **cmd1_argv;
  char **cmd2_argv;
  char *cmd1_fds[3];
  char *cmd2_fds[3];
}
----

Sample output from your program should look as follows:

Plain command: `ls -l`

[source]
----
cmd1_args: ["ls", "-l", NULL]  /* three-element dynamically-allocated array */
cmd2_args: NULL  /* There is no second command here. */

cmd1_fds[0]: NULL  /* With no I/O redirects, all descriptors are NULL */
cmd1_fds[1]: NULL
cmd1_fds[2]: NULL

cmd2_fds[0]: NULL
cmd2_fds[1]: NULL
cmd2_fds[2]: NULL
----

Pipe only command: `ls | sort`

[source]
----
cmd1_args: ["ls", NULL]  /* two-element dynamically-allocated array containing */
cmd2_args: ["sort", NULL]  /* two-element dynamically-allocated array containing */

cmd1_fds[0]: NULL  /* With no I/O redirects, all descriptors are NULL */
cmd1_fds[1]: NULL
cmd1_fds[2]: NULL

cmd2_fds[0]: NULL
cmd2_fds[1]: NULL
cmd2_fds[2]: NULL
----

Redirects only: `ls -l 1> out.txt 2> error.txt`

[source]
----
cmd1_args: ["ls", "-l", NULL]  /* three-element dynamically-allocated array */

cmd2_args: NULL  /* There is no second command here. */

cmd1_fds[0]: NULL
cmd1_fds[1]: "out.txt"
cmd1_fds[2]: "error.txt"

cmd2_fds[0]: NULL  /* There is no second command here. */
cmd2_fds[1]: NULL
cmd2_fds[2]: NULL
----

Combined: `grep -i blah < input.txt | sort 1> output.txt`

[source]
----
cmd1_args: ["grep", "-i", "blah", NULL]  /* four-element dynamically-allocated array */
cmd2_args: ["sort", NULL]  /* two-element dynamically-allocated array containing */

cmd1_fds[0]: "input.txt"
cmd1_fds[1]: NULL
cmd1_fds[2]: NULL

cmd2_fds[0]: NULL
cmd2_fds[1]: "output.txt"
cmd2_fds[2]: NULL
----

Requirements/Hints:

* Use only C commands, such as malloc/free, for this program
* The comments above are to help you understand what memory you should allocate. Don't print the information in the comments. 
* Make sure you have no memory errors!
* You can extend the above struct if you like, but don't change the given data types!
* You can assume that you will have at most one pipe
* Note that the 2> error.txt, |, and & portions of the command are instructions to the shell and are NOT command ARGV tokens.
* To simplify parsing, you may assume that nothing other than white space (spaces, newlines, etc.) will appear after an ampersand (&), there will be at most one ampersand, and that ampersands will not appear for any reason other than to specify background tasks.

[discrete]
== Submit your work to Github

Add and check in your program using git and then push your changes to Github. 
Run the following command inside your `{ASST}` directory.

[source, subs="attributes"]
----
$ cd {ASST}
$ git add .
$ git commit -m "Descriptive message"
$ git push
----

Run `git status` to check the result of the previous git command.
Check the Github website to make sure that your program uploaded correctly. 

= Grading Rubric

*Assignment rubrics*

Grades are out of 4 points.

* (2 points) Microcat
* (2 points) Parser

*Code rubrics*

For full credit, your C programs must be feature-complete, robust (e.g. run without memory errors or crashing) and 
have good style.

* Some credit lost for missing features or bugs, depending on severity of error
* -12.5% for style errors. See the link:../codingstandard.html[class coding style] here.
* -50% for memory errors
* -100% for failure to checkin work to Github
* -100% for failure to compile on linux using make
